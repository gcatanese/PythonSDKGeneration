# coding: utf-8

"""
    Management API

    Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to version 1 of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v1/companies/{companyId}/webhooks ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area. Use this API key to make requests to:  ```text https://management-live.adyen.com/v1 ```  # noqa: E501

    The version of the OpenAPI document: 1
    Contact: developer-experience@adyen.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field
from openapi_client.models.cardholder_receipt import CardholderReceipt
from openapi_client.models.connectivity import Connectivity
from openapi_client.models.gratuity import Gratuity
from openapi_client.models.hardware import Hardware
from openapi_client.models.nexo import Nexo
from openapi_client.models.offline_processing import OfflineProcessing
from openapi_client.models.opi import Opi
from openapi_client.models.receipt_options import ReceiptOptions
from openapi_client.models.receipt_printing import ReceiptPrinting
from openapi_client.models.signature import Signature
from openapi_client.models.surcharge import Surcharge
from openapi_client.models.timeouts import Timeouts
from openapi_client.models.wifi_profiles import WifiProfiles

class TerminalSettings(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """
    cardholder_receipt: Optional[CardholderReceipt] = Field(None, alias="cardholderReceipt")
    connectivity: Optional[Connectivity] = None
    gratuities: Optional[List[Gratuity]] = Field(None, description="Settings for tipping with or without predefined options to choose from. The maximum number of predefined options is four, or three plus the option to enter a custom tip.")
    hardware: Optional[Hardware] = None
    nexo: Optional[Nexo] = None
    offline_processing: Optional[OfflineProcessing] = Field(None, alias="offlineProcessing")
    opi: Optional[Opi] = None
    receipt_options: Optional[ReceiptOptions] = Field(None, alias="receiptOptions")
    receipt_printing: Optional[ReceiptPrinting] = Field(None, alias="receiptPrinting")
    signature: Optional[Signature] = None
    surcharge: Optional[Surcharge] = None
    timeouts: Optional[Timeouts] = None
    wifi_profiles: Optional[WifiProfiles] = Field(None, alias="wifiProfiles")
    __properties = ["cardholderReceipt", "connectivity", "gratuities", "hardware", "nexo", "offlineProcessing", "opi", "receiptOptions", "receiptPrinting", "signature", "surcharge", "timeouts", "wifiProfiles"]

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> TerminalSettings:
        """Create an instance of TerminalSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of cardholder_receipt
        if self.cardholder_receipt:
            _dict['cardholderReceipt'] = self.cardholder_receipt.to_dict()
        # override the default output from pydantic by calling `to_dict()` of connectivity
        if self.connectivity:
            _dict['connectivity'] = self.connectivity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in gratuities (list)
        _items = []
        if self.gratuities:
            for _item in self.gratuities:
                if _item:
                    _items.append(_item.to_dict())
            _dict['gratuities'] = _items
        # override the default output from pydantic by calling `to_dict()` of hardware
        if self.hardware:
            _dict['hardware'] = self.hardware.to_dict()
        # override the default output from pydantic by calling `to_dict()` of nexo
        if self.nexo:
            _dict['nexo'] = self.nexo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of offline_processing
        if self.offline_processing:
            _dict['offlineProcessing'] = self.offline_processing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of opi
        if self.opi:
            _dict['opi'] = self.opi.to_dict()
        # override the default output from pydantic by calling `to_dict()` of receipt_options
        if self.receipt_options:
            _dict['receiptOptions'] = self.receipt_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of receipt_printing
        if self.receipt_printing:
            _dict['receiptPrinting'] = self.receipt_printing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of signature
        if self.signature:
            _dict['signature'] = self.signature.to_dict()
        # override the default output from pydantic by calling `to_dict()` of surcharge
        if self.surcharge:
            _dict['surcharge'] = self.surcharge.to_dict()
        # override the default output from pydantic by calling `to_dict()` of timeouts
        if self.timeouts:
            _dict['timeouts'] = self.timeouts.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wifi_profiles
        if self.wifi_profiles:
            _dict['wifiProfiles'] = self.wifi_profiles.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> TerminalSettings:
        """Create an instance of TerminalSettings from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return TerminalSettings.parse_obj(obj)

        _obj = TerminalSettings.parse_obj({
            "cardholder_receipt": CardholderReceipt.from_dict(obj.get("cardholderReceipt")) if obj.get("cardholderReceipt") is not None else None,
            "connectivity": Connectivity.from_dict(obj.get("connectivity")) if obj.get("connectivity") is not None else None,
            "gratuities": [Gratuity.from_dict(_item) for _item in obj.get("gratuities")] if obj.get("gratuities") is not None else None,
            "hardware": Hardware.from_dict(obj.get("hardware")) if obj.get("hardware") is not None else None,
            "nexo": Nexo.from_dict(obj.get("nexo")) if obj.get("nexo") is not None else None,
            "offline_processing": OfflineProcessing.from_dict(obj.get("offlineProcessing")) if obj.get("offlineProcessing") is not None else None,
            "opi": Opi.from_dict(obj.get("opi")) if obj.get("opi") is not None else None,
            "receipt_options": ReceiptOptions.from_dict(obj.get("receiptOptions")) if obj.get("receiptOptions") is not None else None,
            "receipt_printing": ReceiptPrinting.from_dict(obj.get("receiptPrinting")) if obj.get("receiptPrinting") is not None else None,
            "signature": Signature.from_dict(obj.get("signature")) if obj.get("signature") is not None else None,
            "surcharge": Surcharge.from_dict(obj.get("surcharge")) if obj.get("surcharge") is not None else None,
            "timeouts": Timeouts.from_dict(obj.get("timeouts")) if obj.get("timeouts") is not None else None,
            "wifi_profiles": WifiProfiles.from_dict(obj.get("wifiProfiles")) if obj.get("wifiProfiles") is not None else None
        })
        return _obj

